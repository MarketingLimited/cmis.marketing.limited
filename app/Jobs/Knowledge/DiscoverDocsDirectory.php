<?php

namespace App\Jobs\Knowledge;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\File;

/**
 * Auto-generates comprehensive documentation index from /docs/ directory.
 *
 * This is the PRIMARY SOURCE OF TRUTH for:
 * - Historical context and past decisions
 * - Past bugs and solutions
 * - Architectural decisions and reasoning
 * - Previous implementation patterns
 * - Known issues and workarounds
 * - Design goals and constraints
 *
 * Generated File: .claude/knowledge/auto-generated/DOCS_INDEX.md
 */
class DiscoverDocsDirectory implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    protected string $outputPath;
    protected string $docsPath;
    protected array $documentsByTopic = [];
    protected array $criticalLessons = [];

    public function __construct()
    {
        $this->outputPath = base_path('.claude/knowledge/auto-generated/DOCS_INDEX.md');
        $this->docsPath = base_path('docs');
    }

    public function handle(): void
    {
        if (!File::isDirectory($this->docsPath)) {
            \Log::warning('Documentation directory not found', ['path' => $this->docsPath]);
            return;
        }

        $content = $this->generateDocsIndex();

        // Ensure directory exists
        File::ensureDirectoryExists(dirname($this->outputPath));

        // Write generated knowledge
        File::put($this->outputPath, $content);

        \Log::info('Documentation index generated', [
            'file' => $this->outputPath,
            'size' => File::size($this->outputPath),
        ]);
    }

    protected function generateDocsIndex(): string
    {
        $timestamp = now()->toIso8601String();

        $markdown = "# Auto-Generated Documentation Index\n\n";
        $markdown .= "**Last Updated:** {$timestamp}\n";
        $markdown .= "**Generated By:** cmis-knowledge-maintainer agent\n\n";
        $markdown .= "---\n\n";

        $markdown .= "## ðŸš¨ PRIMARY SOURCE OF TRUTH\n\n";
        $markdown .= "**BEFORE starting ANY implementation, debugging, planning, or analysis:**\n\n";
        $markdown .= "**ALL agents MUST search and read relevant /docs/ documentation.**\n\n";
        $markdown .= "This ensures:\n";
        $markdown .= "- âœ… Avoid repeating previous mistakes\n";
        $markdown .= "- âœ… Reuse existing solutions and patterns\n";
        $markdown .= "- âœ… Align with established design goals\n";
        $markdown .= "- âœ… Make evidence-based decisions\n";
        $markdown .= "- âœ… Build on prior work, not duplicate it\n\n";
        $markdown .= "---\n\n";

        // Directory structure
        $markdown .= $this->generateDirectoryStructure();

        // All documents list
        $markdown .= $this->generateAllDocumentsList();

        // Documents by topic
        $markdown .= $this->generateDocumentsByTopic();

        // Critical lessons learned
        $markdown .= $this->generateCriticalLessons();

        // Recommended reading by task
        $markdown .= $this->generateRecommendedReading();

        // Quick search commands
        $markdown .= $this->appendSearchCommands();

        return $markdown;
    }

    protected function generateDirectoryStructure(): string
    {
        $markdown = "## ðŸ“š Documentation Directory Structure\n\n";

        $directories = [
            'active' => 'Current work (plans, reports, analysis, progress)',
            'phases' => 'Past implementations (completed, in-progress, planned)',
            'architecture' => 'System design and architectural decisions',
            'guides' => 'Setup, development, and deployment guides',
            'reference' => 'Database schema and API documentation',
            'testing' => 'Testing strategies and test documentation',
            'archive' => 'Archived documentation',
        ];

        foreach ($directories as $dir => $description) {
            $fullPath = $this->docsPath . '/' . $dir;

            if (File::isDirectory($fullPath)) {
                $fileCount = count(File::allFiles($fullPath));
                $markdown .= "### `docs/{$dir}/`\n";
                $markdown .= "- **Purpose:** {$description}\n";
                $markdown .= "- **Files:** {$fileCount} documents\n\n";

                // List subdirectories
                $subdirs = File::directories($fullPath);
                if (!empty($subdirs)) {
                    $markdown .= "**Subdirectories:**\n";
                    foreach ($subdirs as $subdir) {
                        $subdirName = basename($subdir);
                        $subFileCount = count(File::allFiles($subdir));
                        $markdown .= "- `{$subdirName}/` ({$subFileCount} files)\n";
                    }
                    $markdown .= "\n";
                }
            }
        }

        $markdown .= "---\n\n";

        return $markdown;
    }

    protected function generateAllDocumentsList(): string
    {
        $markdown = "## ðŸ“„ All Documentation Files\n\n";

        $allFiles = File::allFiles($this->docsPath);
        $markdown .= "**Total Documents:** " . count($allFiles) . "\n\n";

        // Group by directory
        $filesByDir = [];
        foreach ($allFiles as $file) {
            $relativePath = str_replace($this->docsPath . '/', '', $file->getPathname());
            $dir = dirname($relativePath);

            if (!isset($filesByDir[$dir])) {
                $filesByDir[$dir] = [];
            }

            $filesByDir[$dir][] = [
                'name' => $file->getFilename(),
                'path' => 'docs/' . $relativePath,
                'size' => $file->getSize(),
                'modified' => date('Y-m-d H:i:s', $file->getMTime()),
            ];
        }

        ksort($filesByDir);

        foreach ($filesByDir as $dir => $files) {
            $markdown .= "### `docs/{$dir}/`\n\n";

            usort($files, fn($a, $b) => strcmp($a['name'], $b['name']));

            foreach ($files as $file) {
                $sizeKB = round($file['size'] / 1024, 1);
                $markdown .= "- **{$file['name']}** ({$sizeKB} KB)\n";
                $markdown .= "  - Path: `{$file['path']}`\n";
                $markdown .= "  - Modified: {$file['modified']}\n";

                // Extract first line as summary if it's a markdown file
                if (str_ends_with($file['name'], '.md')) {
                    $content = File::get(base_path($file['path']));
                    $firstLine = strtok($content, "\n");
                    $firstLine = trim(str_replace('#', '', $firstLine));
                    if (!empty($firstLine) && strlen($firstLine) < 100) {
                        $markdown .= "  - Summary: *{$firstLine}*\n";
                    }
                }

                $markdown .= "\n";
            }
        }

        $markdown .= "---\n\n";

        return $markdown;
    }

    protected function generateDocumentsByTopic(): string
    {
        $markdown = "## ðŸ” Documents by Topic\n\n";
        $markdown .= "*Auto-discovered by scanning document content*\n\n";

        $topics = [
            'Campaign' => ['campaign', 'content plan', 'budget'],
            'Analytics' => ['analytics', 'metrics', 'attribution', 'reporting'],
            'Platform Integration' => ['meta', 'google', 'tiktok', 'oauth', 'webhook'],
            'Multi-Tenancy' => ['rls', 'row-level security', 'tenant', 'organization', 'multi-tenant'],
            'AI & Semantic Search' => ['embedding', 'vector', 'semantic', 'gemini', 'ai'],
            'Database' => ['migration', 'schema', 'postgresql', 'database'],
            'Testing' => ['test', 'phpunit', 'mock', 'fixture'],
            'Performance' => ['performance', 'optimization', 'slow', 'cache', 'n+1'],
            'Security' => ['security', 'vulnerability', 'authentication', 'authorization'],
            'Bug Fixes' => ['bug', 'fix', 'issue', 'error', 'problem'],
            'Refactoring' => ['refactor', 'redesign', 'cleanup', 'duplicate'],
        ];

        $allFiles = File::allFiles($this->docsPath);

        foreach ($topics as $topic => $keywords) {
            $relatedDocs = [];

            foreach ($allFiles as $file) {
                if (!str_ends_with($file->getFilename(), '.md')) {
                    continue;
                }

                $content = strtolower(File::get($file->getPathname()));
                $filename = strtolower($file->getFilename());

                $found = false;
                foreach ($keywords as $keyword) {
                    if (str_contains($content, strtolower($keyword)) || str_contains($filename, strtolower($keyword))) {
                        $found = true;
                        break;
                    }
                }

                if ($found) {
                    $relativePath = str_replace($this->docsPath . '/', '', $file->getPathname());
                    $relatedDocs[] = 'docs/' . $relativePath;
                }
            }

            if (!empty($relatedDocs)) {
                $markdown .= "### {$topic}\n\n";
                $markdown .= "**Keywords:** " . implode(', ', $keywords) . "\n\n";
                $markdown .= "**Related Documents:**\n";

                foreach (array_slice($relatedDocs, 0, 10) as $doc) {
                    $markdown .= "- `{$doc}`\n";
                }

                if (count($relatedDocs) > 10) {
                    $remaining = count($relatedDocs) - 10;
                    $markdown .= "- *... and {$remaining} more*\n";
                }

                $markdown .= "\n";
            }
        }

        $markdown .= "---\n\n";

        return $markdown;
    }

    protected function generateCriticalLessons(): string
    {
        $markdown = "## âš ï¸ Critical Lessons Learned\n\n";
        $markdown .= "*Auto-extracted from documentation*\n\n";

        $categories = [
            'Past Bugs and Fixes' => ['bug', 'fix', 'issue', 'error', 'resolved'],
            'Performance Issues Solved' => ['performance', 'optimization', 'slow', 'bottleneck'],
            'Architecture Changes' => ['refactor', 'redesign', 'migration', 'breaking change'],
            'Known Issues' => ['known issue', 'workaround', 'limitation', 'caveat'],
        ];

        $allFiles = File::allFiles($this->docsPath);

        foreach ($categories as $category => $keywords) {
            $findings = [];

            foreach ($allFiles as $file) {
                if (!str_ends_with($file->getFilename(), '.md')) {
                    continue;
                }

                $content = File::get($file->getPathname());
                $lines = explode("\n", $content);

                foreach ($lines as $lineNum => $line) {
                    $lowerLine = strtolower($line);

                    foreach ($keywords as $keyword) {
                        if (str_contains($lowerLine, strtolower($keyword))) {
                            $relativePath = str_replace($this->docsPath . '/', '', $file->getPathname());

                            // Get context (line itself and next 2 lines)
                            $context = trim($line);
                            if (strlen($context) > 0 && strlen($context) < 150) {
                                $findings[] = [
                                    'file' => 'docs/' . $relativePath,
                                    'line' => $lineNum + 1,
                                    'context' => $context,
                                ];
                            }
                            break;
                        }
                    }

                    if (count($findings) >= 20) break 2; // Limit per category
                }
            }

            if (!empty($findings)) {
                $markdown .= "### {$category}\n\n";

                foreach (array_slice($findings, 0, 10) as $finding) {
                    $markdown .= "- **{$finding['file']}:{$finding['line']}**\n";
                    $markdown .= "  > {$finding['context']}\n\n";
                }

                if (count($findings) > 10) {
                    $remaining = count($findings) - 10;
                    $markdown .= "*... and {$remaining} more entries*\n\n";
                }
            } else {
                $markdown .= "### {$category}\n\n";
                $markdown .= "*No entries found*\n\n";
            }
        }

        $markdown .= "---\n\n";

        return $markdown;
    }

    protected function generateRecommendedReading(): string
    {
        $markdown = "## ðŸŽ¯ Recommended Reading by Task Type\n\n";
        $markdown .= "*What to read before starting specific types of work*\n\n";

        $recommendations = [
            'Adding New Feature' => [
                'docs/architecture/*.md',
                'docs/guides/development/*.md',
                'Search docs/ for similar past features',
            ],
            'Fixing Bug' => [
                'Search docs/ for similar past issues',
                'docs/phases/completed/ for related fixes',
                'docs/testing/ for test strategies',
            ],
            'Performance Optimization' => [
                'docs/active/analysis/ for performance reports',
                'docs/architecture/ for system constraints',
                'Search docs/ for "performance", "optimization", "slow"',
            ],
            'Database Changes' => [
                'docs/reference/database/*.md',
                'docs/architecture/multi-tenancy*.md',
                'docs/phases/completed/ for past migrations',
            ],
            'Platform Integration' => [
                'docs/phases/completed/ for existing integrations',
                'docs/architecture/ for integration patterns',
                'Search docs/ for platform name (Meta, Google, etc.)',
            ],
            'Refactoring' => [
                'docs/phases/completed/duplication-elimination/*.md',
                'docs/architecture/ for current patterns',
                'Search docs/ for past refactoring efforts',
            ],
        ];

        foreach ($recommendations as $taskType => $readings) {
            $markdown .= "### {$taskType}\n\n";
            $markdown .= "**Must read before starting:**\n\n";

            foreach ($readings as $reading) {
                $markdown .= "- {$reading}\n";
            }

            $markdown .= "\n";
        }

        $markdown .= "---\n\n";

        return $markdown;
    }

    protected function appendSearchCommands(): string
    {
        $markdown = "## ðŸ” Quick Search Commands\n\n";
        $markdown .= "*Use these commands to find relevant documentation*\n\n";

        $markdown .= "### Search for Keyword\n\n";
        $markdown .= "```bash\n";
        $markdown .= "# Search all docs for keyword\n";
        $markdown .= "grep -r \"keyword\" docs/ --include=\"*.md\"\n\n";
        $markdown .= "# Case-insensitive search\n";
        $markdown .= "grep -ri \"keyword\" docs/ --include=\"*.md\"\n\n";
        $markdown .= "# Search with context (3 lines before/after)\n";
        $markdown .= "grep -ri -C 3 \"keyword\" docs/ --include=\"*.md\"\n";
        $markdown .= "```\n\n";

        $markdown .= "### List All Documents\n\n";
        $markdown .= "```bash\n";
        $markdown .= "# All markdown files\n";
        $markdown .= "find docs/ -name \"*.md\" -type f | sort\n\n";
        $markdown .= "# Recently modified (last 7 days)\n";
        $markdown .= "find docs/ -name \"*.md\" -type f -mtime -7\n\n";
        $markdown .= "# Large documents (>50 KB)\n";
        $markdown .= "find docs/ -name \"*.md\" -type f -size +50k\n";
        $markdown .= "```\n\n";

        $markdown .= "### Search by Directory\n\n";
        $markdown .= "```bash\n";
        $markdown .= "# Active work\n";
        $markdown .= "ls -lah docs/active/\n\n";
        $markdown .= "# Completed phases\n";
        $markdown .= "ls -lah docs/phases/completed/\n\n";
        $markdown .= "# Architecture docs\n";
        $markdown .= "ls -lah docs/architecture/\n";
        $markdown .= "```\n\n";

        $markdown .= "### Using Artisan Command\n\n";
        $markdown .= "```bash\n";
        $markdown .= "# Quick search with artisan\n";
        $markdown .= "php artisan docs:search \"keyword\"\n\n";
        $markdown .= "# Generate fresh docs index\n";
        $markdown .= "php artisan knowledge:generate-docs-index\n";
        $markdown .= "```\n\n";

        return $markdown;
    }
}
