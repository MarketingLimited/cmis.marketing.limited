<?php

namespace App\Jobs\Knowledge;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\File;

/**
 * Auto-generates visual model relationship graph showing:
 * - Model hierarchies by domain
 * - Relationships (belongsTo, hasMany, etc.)
 * - Polymorphic relationships
 * - Multi-tenancy patterns
 *
 * Generated File: .claude/knowledge/auto-generated/MODEL_RELATIONSHIP_GRAPH.md
 */
class DiscoverModelGraph implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    protected string $outputPath;
    protected array $modelData = [];

    public function __construct()
    {
        $this->outputPath = base_path('.claude/knowledge/auto-generated/MODEL_RELATIONSHIP_GRAPH.md');
    }

    public function handle(): void
    {
        $this->discoverModels();
        $content = $this->generateModelGraph();

        // Ensure directory exists
        File::ensureDirectoryExists(dirname($this->outputPath));

        // Write generated knowledge
        File::put($this->outputPath, $content);

        \Log::info('Model relationship graph generated', [
            'file' => $this->outputPath,
            'size' => File::size($this->outputPath),
        ]);
    }

    protected function discoverModels(): void
    {
        $modelFiles = File::allFiles(app_path('Models'));

        foreach ($modelFiles as $file) {
            $content = File::get($file->getPathname());
            $namespace = $this->extractNamespace($content);
            $className = $file->getFilenameWithoutExtension();
            $fullClassName = $namespace . '\\' . $className;

            $this->modelData[$fullClassName] = [
                'name' => $className,
                'namespace' => $namespace,
                'file' => str_replace(base_path() . '/', '', $file->getPathname()),
                'relationships' => $this->extractRelationships($content),
                'uses_has_organization' => str_contains($content, 'use HasOrganization'),
                'extends_base_model' => str_contains($content, 'extends BaseModel'),
            ];
        }
    }

    protected function generateModelGraph(): string
    {
        $timestamp = now()->toIso8601String();

        $markdown = "# Auto-Generated Model Relationship Graph\n\n";
        $markdown .= "**Last Updated:** {$timestamp}\n";
        $markdown .= "**Generated By:** cmis-knowledge-maintainer agent\n\n";
        $markdown .= "---\n\n";

        // Group models by domain
        $domains = $this->groupModelsByDomain();

        $markdown .= "## ðŸ“Š Model Summary\n\n";
        $markdown .= "- **Total Models:** " . count($this->modelData) . "\n";
        $markdown .= "- **Domains:** " . count($domains) . "\n";
        $markdown .= "- **Multi-Tenant Models:** " . $this->countMultiTenantModels() . "\n";
        $markdown .= "- **BaseModel Extended:** " . $this->countBaseModelExtended() . "\n\n";

        $markdown .= "---\n\n";

        // Generate graphs by domain
        foreach ($domains as $domain => $models) {
            $markdown .= "## Domain: {$domain}\n\n";
            $markdown .= "**Models in this domain:** " . count($models) . "\n\n";

            // Generate relationship tree
            $markdown .= $this->generateDomainTree($models);
            $markdown .= "\n";

            // Detailed relationship breakdown
            $markdown .= "### Detailed Relationships\n\n";
            foreach ($models as $modelClass => $data) {
                if (!empty($data['relationships'])) {
                    $markdown .= "#### {$data['name']}\n\n";
                    $markdown .= "- **File:** `{$data['file']}`\n";
                    $markdown .= "- **Multi-Tenant:** " . ($data['uses_has_organization'] ? 'âœ… Yes' : 'âŒ No') . "\n";
                    $markdown .= "- **Extends BaseModel:** " . ($data['extends_base_model'] ? 'âœ… Yes' : 'âŒ No') . "\n";
                    $markdown .= "- **Relationships:**\n";

                    foreach ($data['relationships'] as $rel) {
                        $markdown .= "  - **`{$rel['type']}`** `{$rel['name']}()` â†’ `{$rel['related']}`\n";
                    }

                    $markdown .= "\n";
                }
            }

            $markdown .= "---\n\n";
        }

        // Polymorphic relationships
        $markdown .= $this->generatePolymorphicSection();

        // Discovery commands
        $markdown .= $this->appendDiscoveryCommands();

        return $markdown;
    }

    protected function groupModelsByDomain(): array
    {
        $domains = [];

        foreach ($this->modelData as $fullClassName => $data) {
            $namespace = $data['namespace'];

            // Extract domain from namespace (e.g., App\Models\Campaign -> Campaign)
            $parts = explode('\\', $namespace);
            $domain = count($parts) > 2 ? end($parts) : 'Core';

            if (!isset($domains[$domain])) {
                $domains[$domain] = [];
            }

            $domains[$domain][$fullClassName] = $data;
        }

        ksort($domains);

        return $domains;
    }

    protected function generateDomainTree(array $models): string
    {
        $tree = "```\n";

        // Find root models (those with Organization relationship)
        $rootModels = [];
        $childModels = [];

        foreach ($models as $modelClass => $data) {
            $hasOrgRelation = false;
            foreach ($data['relationships'] as $rel) {
                if ($rel['type'] === 'belongsTo' && str_contains($rel['related'], 'Organization')) {
                    $hasOrgRelation = true;
                    break;
                }
            }

            if ($hasOrgRelation) {
                $rootModels[$modelClass] = $data;
            } else {
                $childModels[$modelClass] = $data;
            }
        }

        // Build tree structure
        if (!empty($rootModels)) {
            $tree .= "Organization (parent)\n";
            foreach ($rootModels as $modelClass => $data) {
                $tree .= "â”œâ”€â”€ {$data['name']}\n";
                $tree .= $this->buildChildTree($data, $models, 1);
            }
        } else {
            // No org relationship, just list models
            foreach ($models as $modelClass => $data) {
                $tree .= "{$data['name']}\n";
                $tree .= $this->buildChildTree($data, $models, 0);
            }
        }

        $tree .= "```\n\n";

        return $tree;
    }

    protected function buildChildTree(array $parentData, array $allModels, int $depth = 0): string
    {
        $tree = '';
        $indent = str_repeat('â”‚   ', $depth);
        $connector = $depth > 0 ? 'â”œâ”€â”€ ' : '';

        // Find children (hasMany, hasOne relationships)
        $children = [];
        foreach ($parentData['relationships'] as $rel) {
            if (in_array($rel['type'], ['hasMany', 'hasOne', 'morphMany'])) {
                $children[] = $rel;
            }
        }

        foreach ($children as $i => $child) {
            $isLast = $i === count($children) - 1;
            $prefix = $isLast ? 'â””â”€â”€ ' : 'â”œâ”€â”€ ';

            // Simplify related model name
            $relatedName = $this->simplifyModelName($child['related']);

            $tree .= "{$indent}{$prefix}{$relatedName} ({$child['type']})\n";

            // Recursively build children if model exists
            $relatedModel = $this->findModelByName($child['related'], $allModels);
            if ($relatedModel && $depth < 3) { // Limit depth to prevent infinite loops
                $tree .= $this->buildChildTree($relatedModel, $allModels, $depth + 1);
            }
        }

        return $tree;
    }

    protected function simplifyModelName(string $fullName): string
    {
        // Extract class name from full class path
        $parts = explode('\\', trim($fullName, '\\'));
        return end($parts);
    }

    protected function findModelByName(string $name, array $allModels): ?array
    {
        $simpleName = $this->simplifyModelName($name);

        foreach ($allModels as $modelClass => $data) {
            if ($data['name'] === $simpleName) {
                return $data;
            }
        }

        return null;
    }

    protected function generatePolymorphicSection(): string
    {
        $markdown = "## ðŸ”€ Polymorphic Relationships\n\n";

        $polymorphicModels = [];
        foreach ($this->modelData as $fullClassName => $data) {
            $hasPolymorphic = false;
            foreach ($data['relationships'] as $rel) {
                if (in_array($rel['type'], ['morphTo', 'morphMany', 'morphOne'])) {
                    $hasPolymorphic = true;
                    $polymorphicModels[$fullClassName] = $data;
                    break;
                }
            }
        }

        if (empty($polymorphicModels)) {
            $markdown .= "*No polymorphic relationships found.*\n\n";
        } else {
            foreach ($polymorphicModels as $modelClass => $data) {
                $markdown .= "### {$data['name']}\n\n";
                $markdown .= "- **File:** `{$data['file']}`\n";
                $markdown .= "- **Polymorphic Relationships:**\n";

                foreach ($data['relationships'] as $rel) {
                    if (in_array($rel['type'], ['morphTo', 'morphMany', 'morphOne'])) {
                        $markdown .= "  - **`{$rel['type']}`** `{$rel['name']}()` â†’ `{$rel['related']}`\n";
                    }
                }

                $markdown .= "\n";
            }
        }

        $markdown .= "---\n\n";

        return $markdown;
    }

    protected function countMultiTenantModels(): int
    {
        return count(array_filter($this->modelData, fn($m) => $m['uses_has_organization']));
    }

    protected function countBaseModelExtended(): int
    {
        return count(array_filter($this->modelData, fn($m) => $m['extends_base_model']));
    }

    protected function appendDiscoveryCommands(): string
    {
        $markdown = "## ðŸ” Discovery Commands\n\n";
        $markdown .= "*Use these commands to discover model relationships:*\n\n";

        $markdown .= "### Find All Models\n\n";
        $markdown .= "```bash\n";
        $markdown .= "find app/Models -name '*.php' -type f\n";
        $markdown .= "```\n\n";

        $markdown .= "### Count Models by Namespace\n\n";
        $markdown .= "```bash\n";
        $markdown .= "find app/Models -name '*.php' -type f | \\\n";
        $markdown .= "  xargs -I {} dirname {} | \\\n";
        $markdown .= "  sort | uniq -c\n";
        $markdown .= "```\n\n";

        $markdown .= "### Find Models Using HasOrganization\n\n";
        $markdown .= "```bash\n";
        $markdown .= "grep -r \"use HasOrganization\" app/Models | wc -l\n";
        $markdown .= "```\n\n";

        $markdown .= "### Find Models Extending BaseModel\n\n";
        $markdown .= "```bash\n";
        $markdown .= "grep -r \"extends BaseModel\" app/Models | wc -l\n";
        $markdown .= "```\n\n";

        $markdown .= "### Find Polymorphic Relationships\n\n";
        $markdown .= "```bash\n";
        $markdown .= "grep -r \"morphTo\\|morphMany\\|morphOne\" app/Models\n";
        $markdown .= "```\n\n";

        return $markdown;
    }

    // Helper methods

    protected function extractNamespace(string $content): string
    {
        preg_match('/namespace\s+([^;]+);/', $content, $matches);
        return $matches[1] ?? 'Unknown';
    }

    protected function extractRelationships(string $content): array
    {
        $relationships = [];
        $relationshipTypes = [
            'belongsTo',
            'hasMany',
            'hasOne',
            'belongsToMany',
            'morphTo',
            'morphMany',
            'morphOne',
            'hasManyThrough',
        ];

        foreach ($relationshipTypes as $type) {
            // Match: public function relationName() { return $this->relationshipType(Model::class); }
            $pattern = '/(?:public\s+)?function\s+(\w+)\s*\([^)]*\)\s*(?::\s*\w+)?\s*{[^}]*return\s+\$this->' . $type . '\s*\(([^)]+)\)/s';

            if (preg_match_all($pattern, $content, $matches, PREG_SET_ORDER)) {
                foreach ($matches as $match) {
                    $relatedModel = trim(explode(',', $match[2])[0], '\'" ');

                    $relationships[] = [
                        'type' => $type,
                        'name' => $match[1],
                        'related' => $relatedModel,
                    ];
                }
            }
        }

        return $relationships;
    }
}
